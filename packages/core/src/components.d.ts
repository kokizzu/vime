/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { MediaPreloadOption } from "./components/providers/file/MediaFileProvider";
import { Params } from "./utils/network";
import { EmbedEvent, EmbedEventPayload } from "./components/core/embed/EmbedEvent";
import { MediaProvider, MediaProviderAdapter, MockMediaProviderAdapter } from "./components/providers/MediaProvider";
import { PlayerProp, PlayerProps } from "./components/core/player/PlayerProp";
import { ViewType } from "./components/core/player/ViewType";
import { MediaType } from "./components/core/player/MediaType";
export namespace Components {
    interface VimeAudio {
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLMediaElement>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; }>;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "willAttach": boolean;
    }
    interface VimeDailymotion {
        "autoplay": boolean;
        /**
          * Change the default highlight color used in the controls (hex value without the leading #). Color set in the Partner HQ will override this prop.
         */
        "color"?: string;
        "controls": boolean;
        "debug": boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLVimeEmbedElement>; play: () => Promise<void>; pause: () => Promise<void>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackQuality: () => Promise<boolean>; setPlaybackQuality: (quality: string) => Promise<void>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<void>; exitFullscreen: () => Promise<void>; }>;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        "playsinline": boolean;
        /**
          * Whether to automatically play the next video in the queue.
         */
        "shouldAutoplayQueue": boolean;
        /**
          * Whether to display the Dailymotion logo.
         */
        "showDailymotionLogo": boolean;
        /**
          * Whether to show buttons for sharing the video.
         */
        "showShareButtons": boolean;
        /**
          * Whether to show the 'Up Next' queue.
         */
        "showUpNextQueue": boolean;
        /**
          * Whether to show video information (title and owner) on the start screen.
         */
        "showVideoInfo": boolean;
        /**
          * Forwards your syndication key to the player.
         */
        "syndication"?: string;
        /**
          * The Dailymotion resource ID of the video to load.
         */
        "videoId": string;
    }
    interface VimeDash {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        "autoplay": boolean;
        /**
          * The `dashjs` configuration.
         */
        "config": Record<string, any>;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<any>; canPlay: (type: any) => Promise<boolean>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; }>;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        /**
          * The URL of the `manifest.mpd` file to use.
         */
        "src": string;
        /**
          * The NPM package version of the `dashjs` library to download and use.
         */
        "version": string;
    }
    interface VimeEmbed {
        /**
          * A function which accepts the raw message received from the embedded media player via `postMessage` and converts it into a POJO.
         */
        "decoder"?: (data: string) => Params | undefined;
        /**
          * A URL that will load the external player and media (Eg: https://www.youtube.com/embed/DyTCOwB0DVw).
         */
        "embedSrc": string;
        /**
          * Whether the embedded player should defer loading until it enters the viewport.
         */
        "lazy": boolean;
        /**
          * The title of the current media so it can be set on the inner `iframe` for screen readers.
         */
        "mediaTitle": string;
        /**
          * Where the src request had originated from without any path information.
         */
        "origin"?: string;
        /**
          * The parameters to pass to the embedded player. These are encoded as a query string and appended to the `embedSrc` prop.
         */
        "params": Params;
        /**
          * Posts a message to the embedded media player.
         */
        "postMessage": (message: any, target?: string | undefined) => Promise<void>;
        /**
          * A collection of URLs to that the browser should immediately start establishing a connection with.
         */
        "preconnections": string[];
    }
    interface VimeFaketube {
        "autoplay": boolean;
        "controls": boolean;
        "debug": boolean;
        /**
          * Dispatches the `vLoadStart` event.
         */
        "dispatchLoadStart": () => Promise<void>;
        /**
          * Dispatches a state change event.
         */
        "dispatchStateChange": (prop: PlayerProp, value: any) => Promise<void>;
        /**
          * Returns a mock adapter.
         */
        "getAdapter": () => Promise<MockMediaProviderAdapter>;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        "playsinline": boolean;
    }
    interface VimeFile {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        "autoplay": boolean;
        "controls": boolean;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        "debug": boolean;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLMediaElement>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; }>;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        /**
          * The playback rates that are available for this media.
         */
        "playbackRates": number[];
        "playsinline": boolean;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        /**
          * Whether to use an `audio` or `video` element to play the media.
         */
        "viewType"?: ViewType;
        "willAttach": boolean;
    }
    interface VimeHls {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        /**
          * The `hls.js` configuration.
         */
        "config"?: Hls.Config;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<import("/Users/rahim/Desktop/vime/node_modules/.pnpm/@types/hls.js@0.13.0/node_modules/@types/hls.js/index") | undefined>; canPlay: (type: any) => Promise<boolean>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; }>;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        /**
          * The NPM package version of the `hls.js` library to download and use if HLS is not natively supported.
         */
        "version": string;
    }
    interface VimeIcon {
        /**
          * The color (fill) of the icon.
         */
        "color": string;
        /**
          * The icon SVG identifier. It's expected that this points to an SVG inside a loaded sprite.
         */
        "icon"?: string;
        /**
          * The amount of transparency to add to the icon.
         */
        "opacity": number;
        /**
          * The amount to scale the size of the icon (respecting aspect ratio) up or down by.
         */
        "scale": number;
    }
    interface VimePlayer {
        /**
          * The aspect ratio of the player expressed as `width:height` (`16:9`). This is only applied if the `viewType` is `video` and the player is not in fullscreen mode.
          * @inheritDoc
         */
        "aspectRatio": string;
        /**
          * Whether the player should automatically pause when another Vime player starts/resumes playback.
          * @inheritDoc
         */
        "autopause": boolean;
        /**
          * Whether playback should automatically begin playing once the media is ready to do so. This will only work if the browsers `autoplay` policies have been satisfied. It'll generally work if the player is muted, or the user frequently interacts with your site. You can check if it's possible to autoplay via the `canAutoplay()` or `canMutedAutoplay()` methods. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "autoplay": boolean;
        /**
          * `@readonly` The length of the media in seconds that has been downloaded by the browser.
          * @inheritDoc
         */
        "buffered": number;
        /**
          * `@readonly` Whether playback has temporarily stopped because of a lack of temporary data.
          * @inheritDoc
         */
        "buffering": boolean;
        "callAdapter": (method: keyof MediaProviderAdapter, value?: any) => Promise<any>;
        /**
          * Determines whether the player can start playback of the current media automatically.
          * @inheritDoc
         */
        "canAutoplay": () => Promise<boolean>;
        /**
          * Determines whether the player can start playback of the current media automatically given the player is muted.
          * @inheritDoc
         */
        "canMutedAutoplay": () => Promise<boolean>;
        /**
          * Determines whether the current provider recognizes, and can play the given type.
          * @inheritDoc
         */
        "canPlay": (type: string) => Promise<boolean>;
        /**
          * Returns whether the native browser fullscreen API is available, or the current provider can toggle fullscreen mode. This does not mean that the operation is guaranteed to be successful, only that it can be attempted.
          * @inheritDoc
         */
        "canSetFullscreen": () => Promise<boolean>;
        /**
          * Returns whether the current provider exposes an API for entering and exiting picture-in-picture mode. This does not mean the operation is guaranteed to be successful, only that it can be attempted.
          * @inheritDoc
         */
        "canSetPiP": () => Promise<boolean>;
        /**
          * Returns whether the current provider allows setting the `playbackQuality` prop.
          * @inheritDoc
         */
        "canSetPlaybackQuality": () => Promise<boolean>;
        /**
          * Returns whether the current provider allows setting the `playbackRate` prop.
          * @inheritDoc
         */
        "canSetPlaybackRate": () => Promise<boolean>;
        /**
          * Indicates whether a user interface should be shown for controlling the resource. Set this to `false` when you want to provide your own custom controls, and `true` if you want the current provider to supply its own default controls. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "controls": boolean;
        /**
          * `@readonly` The absolute URL of the poster for the current media resource. Defaults to `undefined` if no media/poster has been loaded.
          * @inheritDoc
         */
        "currentPoster"?: string;
        /**
          * `@readonly` The absolute URL of the media resource that has been chosen. Defaults to `undefined` if no media has been loaded.
          * @inheritDoc
         */
        "currentSrc"?: string;
        /**
          * A `double` indicating the current playback time in seconds. Defaults to `0` if the media has not started to play and has not seeked. Setting this value seeks the media to the new time. The value can be set to a minimum of `0` and maximum of the total length of the media (indicated by the duration prop).
          * @inheritDoc
         */
        "currentTime": number;
        /**
          * `@readonly` Whether the player is in debug mode and should `console.log` information about its internal state.
          * @inheritDoc
         */
        "debug": boolean;
        /**
          * `@readonly` A `double` indicating the total playback length of the media in seconds. Defaults to `-1` if no media has been loaded.
          * @inheritDoc
         */
        "duration": number;
        /**
          * Requests to enter fullscreen mode, returning a `Promise` that will resolve if the request is made, or reject with a reason for failure. This method will first attempt to use the browsers native fullscreen API, and then fallback to requesting the provider to do it (if available). Do not rely on a resolved promise to determine if the player is in fullscreen or not. The only way to be certain is by listening to the `vFullscreenChange` event. Some common reasons for failure are: the fullscreen API is not available, the request is made when `viewType` is audio, or the user has not interacted with the page yet.
          * @inheritDoc
         */
        "enterFullscreen": (options?: FullscreenOptions | undefined) => Promise<any>;
        /**
          * Request to enter picture-in-picture (PiP) mode, returning a `Promise` that will resolve if the request is made, or reject with a reason for failure. Do not rely on a resolved promise to determine if the player is in PiP mode or not. The only way to be certain is by listening to the `vPiPChange` event. Some common reasons for failure are the same as the reasons for `enterFullscreen()`.
          * @inheritDoc
         */
        "enterPiP": () => Promise<void | undefined>;
        /**
          * `@readonly` A collection of errors that have occurred ordered by `[oldest, ..., newest]`.
          * @inheritDoc
         */
        "errors": any[];
        /**
          * Requests to exit fullscreen mode, returning a `Promise` that will resolve if the request is successful, or reject with a reason for failure. Refer to `enterFullscreen()` for more information.
          * @inheritDoc
         */
        "exitFullscreen": () => Promise<any>;
        /**
          * Request to exit picture-in-picture mode, returns a `Promise` that will resolve if the request is successful, or reject with a reason for failure. Refer to `enterPiP()` for more information.
          * @inheritDoc
         */
        "exitPiP": () => Promise<void | undefined>;
        /**
          * Extends the translation map for a given language.
          * @inheritDoc
         */
        "extendLanguage": (language: string, translations: Record<string, string>) => Promise<void>;
        /**
          * Returns the current media provider's adapter. Shorthand for `getProvider().getAdapter()`.
         */
        "getAdapter": <InternalPlayerType = any>() => Promise<MediaProviderAdapter<InternalPlayerType>>;
        /**
          * Returns the current media provider
          * @inheritDoc
         */
        "getProvider": <InternalPlayerType = any>() => Promise<MediaProvider<InternalPlayerType>>;
        /**
          * `@readonly` A dictionary of translations for the current language.
          * @inheritDoc
         */
        "i18n": Record<string, string>;
        /**
          * `@readonly` Whether the current media is of type `audio`, shorthand for `mediaType === MediaType.Audio`.
          * @inheritDoc
         */
        "isAudio": boolean;
        /**
          * `@readonly` Whether the current view is of type `audio`, shorthand for `viewType === ViewType.Audio`.
          * @inheritDoc
         */
        "isAudioView": boolean;
        /**
          * `@readonly` Whether the player is currently in fullscreen mode.
          * @inheritDoc
         */
        "isFullscreenActive": boolean;
        /**
          * `@readonly` Whether the current media is being broadcast live.
          * @inheritDoc
         */
        "isLive": boolean;
        /**
          * `@readonly` Whether the player is in mobile mode. This is determined by parsing `window.navigator.userAgent`.
          * @inheritDoc
         */
        "isMobile": boolean;
        /**
          * `@readonly` Whether the player is currently in picture-in-picture mode.
          * @inheritDoc
         */
        "isPiPActive": boolean;
        /**
          * `@readonly` Whether the player is in touch mode. This is determined by listening for mouse/touch events and toggling this value.
          * @inheritDoc
         */
        "isTouch": boolean;
        /**
          * `@readonly` Whether the current media is of type `video`, shorthand for `mediaType === MediaType.Video`.
          * @inheritDoc
         */
        "isVideo": boolean;
        /**
          * `@readonly` Whether the current view is of type `video`, shorthand for `viewType === ViewType.Video`.
          * @inheritDoc
         */
        "isVideoView": boolean;
        /**
          * The current language of the player. This can be any code defined via the `extendLanguage` method or the default `en`. It's recommended to use an ISO 639-1 code as that'll be used by Vime when adding new language defaults in the future.
          * @inheritDoc
         */
        "language": string;
        /**
          * `@readonly` The languages that are currently available. You can add new languages via the `extendLanguage` method.
          * @inheritDoc
         */
        "languages": string[];
        /**
          * Whether media should automatically start playing from the beginning every time it ends.
          * @inheritDoc
         */
        "loop": boolean;
        /**
          * `@readonly` The title of the current media. Defaults to `undefined` if no media has been loaded.
          * @inheritDoc
         */
        "mediaTitle"?: string;
        /**
          * `@readonly` The type of media that is currently active, whether it's audio or video. Defaults to `undefined` when no media has been loaded or the type cannot be determined.
          * @inheritDoc
         */
        "mediaType"?: MediaType;
        /**
          * Whether the audio is muted or not.
          * @inheritDoc
         */
        "muted": boolean;
        /**
          * Pauses playback of the media.
          * @inheritDoc
         */
        "pause": () => Promise<void>;
        /**
          * Whether playback should be paused. Defaults to `true` if no media has loaded or playback has not started. Setting this to `true` will begin/resume playback.
          * @inheritDoc
         */
        "paused": boolean;
        /**
          * Begins/resumes playback of the media. If this method is called programmatically before the user has interacted with the player, the promise may be rejected subject to the browser's autoplay policies.
          * @inheritDoc
         */
        "play": () => Promise<void>;
        /**
          * `@readonly` Whether media playback has reached the end. In other words it'll be true if `currentTime === duration`.
          * @inheritDoc
         */
        "playbackEnded": boolean;
        /**
          * `@readonly` The media qualities available for the current media.
          * @inheritDoc
         */
        "playbackQualities": string[];
        /**
          * Indicates the quality of the media. The value will differ between audio and video. For audio this might be some combination of the encoding format (AAC, MP3), bitrate in kilobits per second (kbps) and sample rate in kilohertz (kHZ). For video this will be the number of vertical pixels it supports. For example, if the video has a resolution of `1920x1080` then the quality will return `1080p`. Defaults to `undefined` which you can interpret as the quality is unknown. The quality can only be set to a quality found in the `playbackQualities` prop. Some providers may not allow changing the quality, you can check if it's possible via `canSetPlaybackQuality()`.
          * @inheritDoc
         */
        "playbackQuality"?: string;
        /**
          * A `double` indicating the rate at which media is being played back. If the value is `<1` then playback is slowed down; if `>1` then playback is sped up. Defaults to `1`. The playback rate can only be set to a rate found in the `playbackRates` prop. Some providers may not allow changing the playback rate, you can check if it's possible via `canSetPlaybackRate()`.
          * @inheritDoc
         */
        "playbackRate": number;
        /**
          * `@readonly` The playback rates available for the current media.
          * @inheritDoc
         */
        "playbackRates": number[];
        /**
          * `@readonly` Whether media is ready for playback to begin.
          * @inheritDoc
         */
        "playbackReady": boolean;
        /**
          * `@readonly` Whether the media has initiated playback. In other words it will be true if `currentTime > 0`.
          * @inheritDoc
         */
        "playbackStarted": boolean;
        /**
          * `@readonly` Whether media is actively playing back. Defaults to `false` if no media has loaded or playback has not started.
          * @inheritDoc
         */
        "playing": boolean;
        /**
          * Whether the video is to be played "inline", that is within the element's playback area. Note that setting this to false does not imply that the video will always be played in fullscreen. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "playsinline": boolean;
        "queuePropChange": (prop: PlayerProp, value: any, by?: string | undefined) => Promise<void>;
        "queueStateChange": (description: string, change: () => Promise<void>) => Promise<void>;
        /**
          * `@readonly` Whether the player is in the process of seeking to a new time position.
          * @inheritDoc
         */
        "seeking": boolean;
        /**
          * `@readonly` The text tracks (WebVTT) associated with the current media.
          * @inheritDoc
         */
        "textTracks"?: TextTrackList;
        /**
          * `@readonly` Contains each language and it's respective translation map.
          * @inheritDoc
         */
        "translations": Record<string, Record<string, string>>;
        /**
          * `@readonly` The type of player view that is being used, whether it's an audio player view or video player view. Normally if the media type is of audio then the view is of type audio, but in some cases it might be desirable to show a different view type. For example, when playing audio with a poster. This is subject to the provider allowing it. Defaults to `undefined` when no media has been loaded.
          * @inheritDoc
         */
        "viewType"?: ViewType;
        /**
          * An `int` between `0` (silent) and `100` (loudest) indicating the audio volume.
          * @inheritDoc
         */
        "volume": number;
    }
    interface VimePoster {
        "currentPoster"?: PlayerProps[PlayerProp.CurrentPoster];
        /**
          * How the poster image should be resized to fit the container (sets the `object-fit` property).
         */
        "fit"?: 'fill' | 'contain' | 'cover' | 'scale-down' | 'none';
        "isVideoView": PlayerProps[PlayerProp.IsVideoView];
        "mediaTitle"?: PlayerProps[PlayerProp.MediaTitle];
        "playbackStarted": PlayerProps[PlayerProp.PlaybackStarted];
    }
    interface VimeSpinner {
        "buffering": PlayerProps[PlayerProp.Buffering];
        "isVideoView": PlayerProps[PlayerProp.IsVideoView];
    }
    interface VimeUi {
    }
    interface VimeVideo {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLMediaElement>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; }>;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "willAttach": boolean;
    }
    interface VimeVimeo {
        "autoplay": boolean;
        /**
          * Whether to display the video owner's name.
         */
        "byline": boolean;
        /**
          * The hexadecimal color value of the playback controls. The embed settings of the video might override this value.
         */
        "color"?: string;
        "controls": boolean;
        "debug": boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLVimeEmbedElement>; play: () => Promise<void>; pause: () => Promise<void>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; }>;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        "playsinline": boolean;
        /**
          * Whether to display the video owner's portrait.
         */
        "portrait": boolean;
        /**
          * The Vimeo resource ID of the video to load.
         */
        "videoId": string;
    }
    interface VimeYoutube {
        "autoplay": boolean;
        "controls": boolean;
        /**
          * Whether cookies should be enabled on the embed.
         */
        "cookies": boolean;
        "debug": boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLVimeEmbedElement>; play: () => Promise<void>; pause: () => Promise<void>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; }>;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        "playsinline": boolean;
        /**
          * Whether the fullscreen control should be shown.
         */
        "showFullscreenControl": boolean;
        /**
          * The YouTube resource ID of the video to load.
         */
        "videoId": string;
    }
}
declare global {
    interface HTMLVimeAudioElement extends Components.VimeAudio, HTMLStencilElement {
    }
    var HTMLVimeAudioElement: {
        prototype: HTMLVimeAudioElement;
        new (): HTMLVimeAudioElement;
    };
    interface HTMLVimeDailymotionElement extends Components.VimeDailymotion, HTMLStencilElement {
    }
    var HTMLVimeDailymotionElement: {
        prototype: HTMLVimeDailymotionElement;
        new (): HTMLVimeDailymotionElement;
    };
    interface HTMLVimeDashElement extends Components.VimeDash, HTMLStencilElement {
    }
    var HTMLVimeDashElement: {
        prototype: HTMLVimeDashElement;
        new (): HTMLVimeDashElement;
    };
    interface HTMLVimeEmbedElement extends Components.VimeEmbed, HTMLStencilElement {
    }
    var HTMLVimeEmbedElement: {
        prototype: HTMLVimeEmbedElement;
        new (): HTMLVimeEmbedElement;
    };
    interface HTMLVimeFaketubeElement extends Components.VimeFaketube, HTMLStencilElement {
    }
    var HTMLVimeFaketubeElement: {
        prototype: HTMLVimeFaketubeElement;
        new (): HTMLVimeFaketubeElement;
    };
    interface HTMLVimeFileElement extends Components.VimeFile, HTMLStencilElement {
    }
    var HTMLVimeFileElement: {
        prototype: HTMLVimeFileElement;
        new (): HTMLVimeFileElement;
    };
    interface HTMLVimeHlsElement extends Components.VimeHls, HTMLStencilElement {
    }
    var HTMLVimeHlsElement: {
        prototype: HTMLVimeHlsElement;
        new (): HTMLVimeHlsElement;
    };
    interface HTMLVimeIconElement extends Components.VimeIcon, HTMLStencilElement {
    }
    var HTMLVimeIconElement: {
        prototype: HTMLVimeIconElement;
        new (): HTMLVimeIconElement;
    };
    interface HTMLVimePlayerElement extends Components.VimePlayer, HTMLStencilElement {
    }
    var HTMLVimePlayerElement: {
        prototype: HTMLVimePlayerElement;
        new (): HTMLVimePlayerElement;
    };
    interface HTMLVimePosterElement extends Components.VimePoster, HTMLStencilElement {
    }
    var HTMLVimePosterElement: {
        prototype: HTMLVimePosterElement;
        new (): HTMLVimePosterElement;
    };
    interface HTMLVimeSpinnerElement extends Components.VimeSpinner, HTMLStencilElement {
    }
    var HTMLVimeSpinnerElement: {
        prototype: HTMLVimeSpinnerElement;
        new (): HTMLVimeSpinnerElement;
    };
    interface HTMLVimeUiElement extends Components.VimeUi, HTMLStencilElement {
    }
    var HTMLVimeUiElement: {
        prototype: HTMLVimeUiElement;
        new (): HTMLVimeUiElement;
    };
    interface HTMLVimeVideoElement extends Components.VimeVideo, HTMLStencilElement {
    }
    var HTMLVimeVideoElement: {
        prototype: HTMLVimeVideoElement;
        new (): HTMLVimeVideoElement;
    };
    interface HTMLVimeVimeoElement extends Components.VimeVimeo, HTMLStencilElement {
    }
    var HTMLVimeVimeoElement: {
        prototype: HTMLVimeVimeoElement;
        new (): HTMLVimeVimeoElement;
    };
    interface HTMLVimeYoutubeElement extends Components.VimeYoutube, HTMLStencilElement {
    }
    var HTMLVimeYoutubeElement: {
        prototype: HTMLVimeYoutubeElement;
        new (): HTMLVimeYoutubeElement;
    };
    interface HTMLElementTagNameMap {
        "vime-audio": HTMLVimeAudioElement;
        "vime-dailymotion": HTMLVimeDailymotionElement;
        "vime-dash": HTMLVimeDashElement;
        "vime-embed": HTMLVimeEmbedElement;
        "vime-faketube": HTMLVimeFaketubeElement;
        "vime-file": HTMLVimeFileElement;
        "vime-hls": HTMLVimeHlsElement;
        "vime-icon": HTMLVimeIconElement;
        "vime-player": HTMLVimePlayerElement;
        "vime-poster": HTMLVimePosterElement;
        "vime-spinner": HTMLVimeSpinnerElement;
        "vime-ui": HTMLVimeUiElement;
        "vime-video": HTMLVimeVideoElement;
        "vime-vimeo": HTMLVimeVimeoElement;
        "vime-youtube": HTMLVimeYoutubeElement;
    }
}
declare namespace LocalJSX {
    interface VimeAudio {
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "willAttach"?: boolean;
    }
    interface VimeDailymotion {
        "autoplay": boolean;
        /**
          * Change the default highlight color used in the controls (hex value without the leading #). Color set in the Partner HQ will override this prop.
         */
        "color"?: string;
        "controls": boolean;
        "debug": boolean;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        "onVLoadStart"?: (event: CustomEvent<void>) => void;
        "playsinline": boolean;
        /**
          * Whether to automatically play the next video in the queue.
         */
        "shouldAutoplayQueue"?: boolean;
        /**
          * Whether to display the Dailymotion logo.
         */
        "showDailymotionLogo"?: boolean;
        /**
          * Whether to show buttons for sharing the video.
         */
        "showShareButtons"?: boolean;
        /**
          * Whether to show the 'Up Next' queue.
         */
        "showUpNextQueue"?: boolean;
        /**
          * Whether to show video information (title and owner) on the start screen.
         */
        "showVideoInfo"?: boolean;
        /**
          * Forwards your syndication key to the player.
         */
        "syndication"?: string;
        /**
          * The Dailymotion resource ID of the video to load.
         */
        "videoId": string;
    }
    interface VimeDash {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        "autoplay": boolean;
        /**
          * The `dashjs` configuration.
         */
        "config"?: Record<string, any>;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        /**
          * The URL of the `manifest.mpd` file to use.
         */
        "src": string;
        /**
          * The NPM package version of the `dashjs` library to download and use.
         */
        "version"?: string;
    }
    interface VimeEmbed {
        /**
          * A function which accepts the raw message received from the embedded media player via `postMessage` and converts it into a POJO.
         */
        "decoder"?: (data: string) => Params | undefined;
        /**
          * A URL that will load the external player and media (Eg: https://www.youtube.com/embed/DyTCOwB0DVw).
         */
        "embedSrc"?: string;
        /**
          * Whether the embedded player should defer loading until it enters the viewport.
         */
        "lazy"?: boolean;
        /**
          * The title of the current media so it can be set on the inner `iframe` for screen readers.
         */
        "mediaTitle"?: string;
        /**
          * Emitted when the embedded player and any new media has loaded.
         */
        "onEmbedLoaded"?: (event: CustomEvent<EmbedEventPayload[EmbedEvent.Loaded]>) => void;
        /**
          * Emitted when a new message is received from the embedded player via `postMessage`.
         */
        "onEmbedMessage"?: (event: CustomEvent<EmbedEventPayload[EmbedEvent.Message]>) => void;
        /**
          * Emitted when the `embedSrc` or `params` props change. The payload contains the `params` serialized into a query string and appended to `embedSrc`.
         */
        "onEmbedSrcChange"?: (event: CustomEvent<EmbedEventPayload[EmbedEvent.SrcChange]>) => void;
        /**
          * Where the src request had originated from without any path information.
         */
        "origin"?: string;
        /**
          * The parameters to pass to the embedded player. These are encoded as a query string and appended to the `embedSrc` prop.
         */
        "params"?: Params;
        /**
          * A collection of URLs to that the browser should immediately start establishing a connection with.
         */
        "preconnections"?: string[];
    }
    interface VimeFaketube {
        "autoplay": boolean;
        "controls": boolean;
        "debug": boolean;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        "onVLoadStart"?: (event: CustomEvent<void>) => void;
        "playsinline": boolean;
    }
    interface VimeFile {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        "autoplay": boolean;
        "controls": boolean;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        "debug": boolean;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        "onVLoadStart"?: (event: CustomEvent<void>) => void;
        /**
          * The playback rates that are available for this media.
         */
        "playbackRates"?: number[];
        "playsinline": boolean;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        /**
          * Whether to use an `audio` or `video` element to play the media.
         */
        "viewType"?: ViewType;
        "willAttach"?: boolean;
    }
    interface VimeHls {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        /**
          * The `hls.js` configuration.
         */
        "config"?: Hls.Config;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        /**
          * The NPM package version of the `hls.js` library to download and use if HLS is not natively supported.
         */
        "version"?: string;
    }
    interface VimeIcon {
        /**
          * The color (fill) of the icon.
         */
        "color"?: string;
        /**
          * The icon SVG identifier. It's expected that this points to an SVG inside a loaded sprite.
         */
        "icon"?: string;
        /**
          * The amount of transparency to add to the icon.
         */
        "opacity"?: number;
        /**
          * The amount to scale the size of the icon (respecting aspect ratio) up or down by.
         */
        "scale"?: number;
    }
    interface VimePlayer {
        /**
          * The aspect ratio of the player expressed as `width:height` (`16:9`). This is only applied if the `viewType` is `video` and the player is not in fullscreen mode.
          * @inheritDoc
         */
        "aspectRatio"?: string;
        /**
          * Whether the player should automatically pause when another Vime player starts/resumes playback.
          * @inheritDoc
         */
        "autopause"?: boolean;
        /**
          * Whether playback should automatically begin playing once the media is ready to do so. This will only work if the browsers `autoplay` policies have been satisfied. It'll generally work if the player is muted, or the user frequently interacts with your site. You can check if it's possible to autoplay via the `canAutoplay()` or `canMutedAutoplay()` methods. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "autoplay"?: boolean;
        /**
          * `@readonly` The length of the media in seconds that has been downloaded by the browser.
          * @inheritDoc
         */
        "buffered"?: number;
        /**
          * `@readonly` Whether playback has temporarily stopped because of a lack of temporary data.
          * @inheritDoc
         */
        "buffering"?: boolean;
        /**
          * Indicates whether a user interface should be shown for controlling the resource. Set this to `false` when you want to provide your own custom controls, and `true` if you want the current provider to supply its own default controls. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "controls"?: boolean;
        /**
          * `@readonly` The absolute URL of the poster for the current media resource. Defaults to `undefined` if no media/poster has been loaded.
          * @inheritDoc
         */
        "currentPoster"?: string;
        /**
          * `@readonly` The absolute URL of the media resource that has been chosen. Defaults to `undefined` if no media has been loaded.
          * @inheritDoc
         */
        "currentSrc"?: string;
        /**
          * A `double` indicating the current playback time in seconds. Defaults to `0` if the media has not started to play and has not seeked. Setting this value seeks the media to the new time. The value can be set to a minimum of `0` and maximum of the total length of the media (indicated by the duration prop).
          * @inheritDoc
         */
        "currentTime"?: number;
        /**
          * `@readonly` Whether the player is in debug mode and should `console.log` information about its internal state.
          * @inheritDoc
         */
        "debug"?: boolean;
        /**
          * `@readonly` A `double` indicating the total playback length of the media in seconds. Defaults to `-1` if no media has been loaded.
          * @inheritDoc
         */
        "duration"?: number;
        /**
          * `@readonly` A collection of errors that have occurred ordered by `[oldest, ..., newest]`.
          * @inheritDoc
         */
        "errors"?: any[];
        /**
          * `@readonly` A dictionary of translations for the current language.
          * @inheritDoc
         */
        "i18n"?: Record<string, string>;
        /**
          * `@readonly` Whether the current media is of type `audio`, shorthand for `mediaType === MediaType.Audio`.
          * @inheritDoc
         */
        "isAudio"?: boolean;
        /**
          * `@readonly` Whether the current view is of type `audio`, shorthand for `viewType === ViewType.Audio`.
          * @inheritDoc
         */
        "isAudioView"?: boolean;
        /**
          * `@readonly` Whether the player is currently in fullscreen mode.
          * @inheritDoc
         */
        "isFullscreenActive"?: boolean;
        /**
          * `@readonly` Whether the current media is being broadcast live.
          * @inheritDoc
         */
        "isLive"?: boolean;
        /**
          * `@readonly` Whether the player is in mobile mode. This is determined by parsing `window.navigator.userAgent`.
          * @inheritDoc
         */
        "isMobile"?: boolean;
        /**
          * `@readonly` Whether the player is currently in picture-in-picture mode.
          * @inheritDoc
         */
        "isPiPActive"?: boolean;
        /**
          * `@readonly` Whether the player is in touch mode. This is determined by listening for mouse/touch events and toggling this value.
          * @inheritDoc
         */
        "isTouch"?: boolean;
        /**
          * `@readonly` Whether the current media is of type `video`, shorthand for `mediaType === MediaType.Video`.
          * @inheritDoc
         */
        "isVideo"?: boolean;
        /**
          * `@readonly` Whether the current view is of type `video`, shorthand for `viewType === ViewType.Video`.
          * @inheritDoc
         */
        "isVideoView"?: boolean;
        /**
          * The current language of the player. This can be any code defined via the `extendLanguage` method or the default `en`. It's recommended to use an ISO 639-1 code as that'll be used by Vime when adding new language defaults in the future.
          * @inheritDoc
         */
        "language"?: string;
        /**
          * `@readonly` The languages that are currently available. You can add new languages via the `extendLanguage` method.
          * @inheritDoc
         */
        "languages"?: string[];
        /**
          * Whether media should automatically start playing from the beginning every time it ends.
          * @inheritDoc
         */
        "loop"?: boolean;
        /**
          * `@readonly` The title of the current media. Defaults to `undefined` if no media has been loaded.
          * @inheritDoc
         */
        "mediaTitle"?: string;
        /**
          * `@readonly` The type of media that is currently active, whether it's audio or video. Defaults to `undefined` when no media has been loaded or the type cannot be determined.
          * @inheritDoc
         */
        "mediaType"?: MediaType;
        /**
          * Whether the audio is muted or not.
          * @inheritDoc
         */
        "muted"?: boolean;
        /**
          * Emitted when the `buffered` prop changes value.
          * @inheritDoc
         */
        "onVBufferedChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Buffered]>) => void;
        /**
          * Emitted when the `buffering` prop changes value.
          * @inheritDoc
         */
        "onVBufferingChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Buffering]>) => void;
        /**
          * Emitted when the `currentPoster` prop changes value.
          * @inheritDoc
         */
        "onVCurrentPosterChange"?: (event: CustomEvent<PlayerProps[PlayerProp.CurrentPoster]>) => void;
        /**
          * Emitted when the `currentSrc` prop changes value.
          * @inheritDoc
         */
        "onVCurrentSrcChange"?: (event: CustomEvent<PlayerProps[PlayerProp.CurrentSrc]>) => void;
        /**
          * Emitted when the `currentTime` prop changes value.
          * @inheritDoc
         */
        "onVCurrentTimeChange"?: (event: CustomEvent<PlayerProps[PlayerProp.CurrentTime]>) => void;
        /**
          * Emitted when the `duration` prop changes value.
          * @inheritDoc
         */
        "onVDurationChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Duration]>) => void;
        /**
          * Emitted when the `errors` prop changes value.
          * @inheritDoc
         */
        "onVErrorsChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Errors]>) => void;
        /**
          * Emitted when the `isFullscreenActive` prop changes value.
          * @inheritDoc
         */
        "onVFullscreenChange"?: (event: CustomEvent<PlayerProps[PlayerProp.IsFullscreenActive]>) => void;
        /**
          * Emitted when the `language` prop changes value.
          * @inheritDoc
         */
        "onVLanguageChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Language]>) => void;
        /**
          * Emitted when the `languages` prop changes value.
          * @inheritDoc
         */
        "onVLanguagesChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Languages]>) => void;
        /**
          * Emitted when the `isLive` prop changes value.
          * @inheritDoc
         */
        "onVLiveChange"?: (event: CustomEvent<PlayerProps[PlayerProp.IsLive]>) => void;
        /**
          * Emitted when the provider starts loading a media resource.
          * @inheritDoc
         */
        "onVLoadStart"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the `mediaTitle` prop changes value.
          * @inheritDoc
         */
        "onVMediaTitleChange"?: (event: CustomEvent<PlayerProps[PlayerProp.MediaTitle]>) => void;
        /**
          * Emitted when the `mediaType` prop changes value.
          * @inheritDoc
         */
        "onVMediaTypeChange"?: (event: CustomEvent<PlayerProps[PlayerProp.MediaType]>) => void;
        /**
          * Emitted when the `muted` prop changes value.
          * @inheritDoc
         */
        "onVMutedChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Muted]>) => void;
        /**
          * Emitted when the `paused` prop changes value.
          * @inheritDoc
         */
        "onVPausedChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Paused]>) => void;
        /**
          * Emitted when the `isPiPActive` prop changes value.
          * @inheritDoc
         */
        "onVPiPChange"?: (event: CustomEvent<PlayerProps[PlayerProp.IsPiPActive]>) => void;
        /**
          * Emitted when the media is transitioning from `paused` to `playing`. Event flow: `paused` -> `play` -> `playing`. The media starts `playing` once enough content has buffered to begin/resume playback.
          * @inheritDoc
         */
        "onVPlay"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when playback reaches the end of the media.
          * @inheritDoc
         */
        "onVPlaybackEnded"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the `playbackQualities` prop changes value.
          * @inheritDoc
         */
        "onVPlaybackQualitiesChange"?: (event: CustomEvent<PlayerProps[PlayerProp.PlaybackQualities]>) => void;
        /**
          * Emitted when the `playbackQuality` prop changes value.
          * @inheritDoc
         */
        "onVPlaybackQualityChange"?: (event: CustomEvent<PlayerProps[PlayerProp.PlaybackQuality]>) => void;
        /**
          * Emitted when the `playbackRate` prop changes value.
          * @inheritDoc
         */
        "onVPlaybackRateChange"?: (event: CustomEvent<PlayerProps[PlayerProp.PlaybackRate]>) => void;
        /**
          * Emitted when the `playbackRates` prop changes value.
          * @inheritDoc
         */
        "onVPlaybackRatesChange"?: (event: CustomEvent<PlayerProps[PlayerProp.PlaybackRates]>) => void;
        /**
          * Emitted when the media is ready to begin playback. The following props are guaranteed to be defined when this fires: `mediaTitle`, `currentSrc`, `currentPoster`, `duration`, `mediaType`, `viewType`.
          * @inheritDoc
         */
        "onVPlaybackReady"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the media initiates playback.
          * @inheritDoc
         */
        "onVPlaybackStarted"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the `playing` prop changes value.
          * @inheritDoc
         */
        "onVPlayingChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Playing]>) => void;
        /**
          * Emitted directly after the player has successfully transitioned/seeked to a new time position. Event flow: `seeking` -> `seeked`.
          * @inheritDoc
         */
        "onVSeeked"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the `seeking` prop changes value.
          * @inheritDoc
         */
        "onVSeekingChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Seeking]>) => void;
        /**
          * Emitted when the `textTracks` prop changes value.
          * @inheritDoc
         */
        "onVTextTracksChange"?: (event: CustomEvent<PlayerProps[PlayerProp.TextTracks]>) => void;
        /**
          * Emitted when the `isTouch` prop changes value.
          * @inheritDoc
         */
        "onVTouchChange"?: (event: CustomEvent<PlayerProps[PlayerProp.IsTouch]>) => void;
        /**
          * Emitted when the `viewType` prop changes value.
          * @inheritDoc
         */
        "onVViewTypeChange"?: (event: CustomEvent<PlayerProps[PlayerProp.ViewType]>) => void;
        /**
          * Emitted when the `volume` prop changes value.
          * @inheritDoc
         */
        "onVVolumeChange"?: (event: CustomEvent<PlayerProps[PlayerProp.Volume]>) => void;
        /**
          * Whether playback should be paused. Defaults to `true` if no media has loaded or playback has not started. Setting this to `true` will begin/resume playback.
          * @inheritDoc
         */
        "paused"?: boolean;
        /**
          * `@readonly` Whether media playback has reached the end. In other words it'll be true if `currentTime === duration`.
          * @inheritDoc
         */
        "playbackEnded"?: boolean;
        /**
          * `@readonly` The media qualities available for the current media.
          * @inheritDoc
         */
        "playbackQualities"?: string[];
        /**
          * Indicates the quality of the media. The value will differ between audio and video. For audio this might be some combination of the encoding format (AAC, MP3), bitrate in kilobits per second (kbps) and sample rate in kilohertz (kHZ). For video this will be the number of vertical pixels it supports. For example, if the video has a resolution of `1920x1080` then the quality will return `1080p`. Defaults to `undefined` which you can interpret as the quality is unknown. The quality can only be set to a quality found in the `playbackQualities` prop. Some providers may not allow changing the quality, you can check if it's possible via `canSetPlaybackQuality()`.
          * @inheritDoc
         */
        "playbackQuality"?: string;
        /**
          * A `double` indicating the rate at which media is being played back. If the value is `<1` then playback is slowed down; if `>1` then playback is sped up. Defaults to `1`. The playback rate can only be set to a rate found in the `playbackRates` prop. Some providers may not allow changing the playback rate, you can check if it's possible via `canSetPlaybackRate()`.
          * @inheritDoc
         */
        "playbackRate"?: number;
        /**
          * `@readonly` The playback rates available for the current media.
          * @inheritDoc
         */
        "playbackRates"?: number[];
        /**
          * `@readonly` Whether media is ready for playback to begin.
          * @inheritDoc
         */
        "playbackReady"?: boolean;
        /**
          * `@readonly` Whether the media has initiated playback. In other words it will be true if `currentTime > 0`.
          * @inheritDoc
         */
        "playbackStarted"?: boolean;
        /**
          * `@readonly` Whether media is actively playing back. Defaults to `false` if no media has loaded or playback has not started.
          * @inheritDoc
         */
        "playing"?: boolean;
        /**
          * Whether the video is to be played "inline", that is within the element's playback area. Note that setting this to false does not imply that the video will always be played in fullscreen. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "playsinline"?: boolean;
        /**
          * `@readonly` Whether the player is in the process of seeking to a new time position.
          * @inheritDoc
         */
        "seeking"?: boolean;
        /**
          * `@readonly` The text tracks (WebVTT) associated with the current media.
          * @inheritDoc
         */
        "textTracks"?: TextTrackList;
        /**
          * `@readonly` Contains each language and it's respective translation map.
          * @inheritDoc
         */
        "translations"?: Record<string, Record<string, string>>;
        /**
          * `@readonly` The type of player view that is being used, whether it's an audio player view or video player view. Normally if the media type is of audio then the view is of type audio, but in some cases it might be desirable to show a different view type. For example, when playing audio with a poster. This is subject to the provider allowing it. Defaults to `undefined` when no media has been loaded.
          * @inheritDoc
         */
        "viewType"?: ViewType;
        /**
          * An `int` between `0` (silent) and `100` (loudest) indicating the audio volume.
          * @inheritDoc
         */
        "volume"?: number;
    }
    interface VimePoster {
        "currentPoster"?: PlayerProps[PlayerProp.CurrentPoster];
        /**
          * How the poster image should be resized to fit the container (sets the `object-fit` property).
         */
        "fit"?: 'fill' | 'contain' | 'cover' | 'scale-down' | 'none';
        "isVideoView": PlayerProps[PlayerProp.IsVideoView];
        "mediaTitle"?: PlayerProps[PlayerProp.MediaTitle];
        "playbackStarted": PlayerProps[PlayerProp.PlaybackStarted];
    }
    interface VimeSpinner {
        "buffering": PlayerProps[PlayerProp.Buffering];
        "isVideoView": PlayerProps[PlayerProp.IsVideoView];
    }
    interface VimeUi {
    }
    interface VimeVideo {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * This enumerated attribute indicates whether to use CORS to fetch the related image.  The allowed values are:  - `anonymous`: Sends a cross-origin request without a credential. In other words, it sends the `Origin: HTTP` header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the Access-Control-Allow-Origin: HTTP header), the image will be tainted, and its usage restricted.  - `use-credentials`: Sends a cross-origin request with a credential. In other words, it sends the `Origin: HTTP` header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through Access-Control-Allow-Credentials: HTTP header), the image will be tainted and its usage restricted.  When not present, the resource is fetched without a CORS request (i.e. without sending the Origin: HTTP header), preventing its non-tainted use in <canvas> elements. If invalid, it is handled as if the enumerated keyword anonymous was used. See CORS settings attributes for additional information.
          * @inheritdoc
         */
        "crossOrigin"?: string;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played.  It may have one of the following values:  - `none`: Indicates that the video should not be preloaded. - `metadata`: Indicates that only video metadata (e.g. length) is fetched. - `auto`: Indicates that the whole video file can be downloaded, even if the user is not expected to use it. - `''` (empty string): Synonym of the auto value.  The default value is different for each browser. The spec advises it to be set to metadata.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "willAttach"?: boolean;
    }
    interface VimeVimeo {
        "autoplay": boolean;
        /**
          * Whether to display the video owner's name.
         */
        "byline"?: boolean;
        /**
          * The hexadecimal color value of the playback controls. The embed settings of the video might override this value.
         */
        "color"?: string;
        "controls": boolean;
        "debug": boolean;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        "onVLoadStart"?: (event: CustomEvent<void>) => void;
        "playsinline": boolean;
        /**
          * Whether to display the video owner's portrait.
         */
        "portrait"?: boolean;
        /**
          * The Vimeo resource ID of the video to load.
         */
        "videoId": string;
    }
    interface VimeYoutube {
        "autoplay": boolean;
        "controls": boolean;
        /**
          * Whether cookies should be enabled on the embed.
         */
        "cookies"?: boolean;
        "debug": boolean;
        "language": string;
        "loop": boolean;
        "muted": boolean;
        "onVLoadStart"?: (event: CustomEvent<void>) => void;
        "playsinline": boolean;
        /**
          * Whether the fullscreen control should be shown.
         */
        "showFullscreenControl"?: boolean;
        /**
          * The YouTube resource ID of the video to load.
         */
        "videoId": string;
    }
    interface IntrinsicElements {
        "vime-audio": VimeAudio;
        "vime-dailymotion": VimeDailymotion;
        "vime-dash": VimeDash;
        "vime-embed": VimeEmbed;
        "vime-faketube": VimeFaketube;
        "vime-file": VimeFile;
        "vime-hls": VimeHls;
        "vime-icon": VimeIcon;
        "vime-player": VimePlayer;
        "vime-poster": VimePoster;
        "vime-spinner": VimeSpinner;
        "vime-ui": VimeUi;
        "vime-video": VimeVideo;
        "vime-vimeo": VimeVimeo;
        "vime-youtube": VimeYoutube;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "vime-audio": LocalJSX.VimeAudio & JSXBase.HTMLAttributes<HTMLVimeAudioElement>;
            "vime-dailymotion": LocalJSX.VimeDailymotion & JSXBase.HTMLAttributes<HTMLVimeDailymotionElement>;
            "vime-dash": LocalJSX.VimeDash & JSXBase.HTMLAttributes<HTMLVimeDashElement>;
            "vime-embed": LocalJSX.VimeEmbed & JSXBase.HTMLAttributes<HTMLVimeEmbedElement>;
            "vime-faketube": LocalJSX.VimeFaketube & JSXBase.HTMLAttributes<HTMLVimeFaketubeElement>;
            "vime-file": LocalJSX.VimeFile & JSXBase.HTMLAttributes<HTMLVimeFileElement>;
            "vime-hls": LocalJSX.VimeHls & JSXBase.HTMLAttributes<HTMLVimeHlsElement>;
            "vime-icon": LocalJSX.VimeIcon & JSXBase.HTMLAttributes<HTMLVimeIconElement>;
            "vime-player": LocalJSX.VimePlayer & JSXBase.HTMLAttributes<HTMLVimePlayerElement>;
            "vime-poster": LocalJSX.VimePoster & JSXBase.HTMLAttributes<HTMLVimePosterElement>;
            "vime-spinner": LocalJSX.VimeSpinner & JSXBase.HTMLAttributes<HTMLVimeSpinnerElement>;
            "vime-ui": LocalJSX.VimeUi & JSXBase.HTMLAttributes<HTMLVimeUiElement>;
            "vime-video": LocalJSX.VimeVideo & JSXBase.HTMLAttributes<HTMLVimeVideoElement>;
            "vime-vimeo": LocalJSX.VimeVimeo & JSXBase.HTMLAttributes<HTMLVimeVimeoElement>;
            "vime-youtube": LocalJSX.VimeYoutube & JSXBase.HTMLAttributes<HTMLVimeYoutubeElement>;
        }
    }
}
