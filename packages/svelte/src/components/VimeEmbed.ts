/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
import { Components, JSX } from '@vime/core';


interface VimeEmbedProps {
  
  /** A URL that will load the external player and media (Eg: https://www.youtube.com/embed/DyTCOwB0DVw). */
  embedSrc?: Components.VimeEmbed["embedSrc"]
  
  /** The title of the current media so it can be set on the inner `iframe` for screen readers. */
  mediaTitle?: Components.VimeEmbed["mediaTitle"]
  
  /** The parameters to pass to the embedded player which are appended to the `embedSrc` prop. These
can be passed in as a query string or object. */
  params?: Components.VimeEmbed["params"]
  
  /** Where the src request had originated from without any path information. */
  origin?: Components.VimeEmbed["origin"]
  
  /** A collection of URLs to that the browser should immediately start establishing a connection
with. */
  preconnections?: Components.VimeEmbed["preconnections"]
  
  /** A function which accepts the raw message received from the embedded media player via
`postMessage` and converts it into a POJO. */
  decoder?: Components.VimeEmbed["decoder"]
}

interface VimeEmbedEvents {
  
  /** Emitted when the `embedSrc` or `params` props change. The payload contains the `params`
serialized into a query string and appended to `embedSrc`. */
  vEmbedSrcChange: Parameters<JSX.VimeEmbed["onVEmbedSrcChange"]>[0]
  
  /** Emitted when a new message is received from the embedded player via `postMessage`. */
  vEmbedMessage: Parameters<JSX.VimeEmbed["onVEmbedMessage"]>[0]
  
  /** Emitted when the embedded player and any new media has loaded. */
  vEmbedLoaded: Parameters<JSX.VimeEmbed["onVEmbedLoaded"]>[0]
}

interface VimeEmbedSlots {
  default: any
}
  
/* generated by Svelte v3.24.1 */
import {
	SvelteComponent,
	binding_callbacks,
	create_slot,
	detach,
	element,
	init,
	insert,
	listen,
	run_all,
	safe_not_equal,
	set_custom_element_data,
	transition_in,
	transition_out,
	update_slot
} from "svelte/internal";

import { createEventDispatcher, onMount } from "svelte";

function create_fragment(ctx) {
	let vime_embed;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	return {
		c() {
			vime_embed = element("vime-embed");
			if (default_slot) default_slot.c();
			set_custom_element_data(vime_embed, "embed-src", /*embedSrc*/ ctx[0]);
			set_custom_element_data(vime_embed, "media-title", /*mediaTitle*/ ctx[1]);
			set_custom_element_data(vime_embed, "params", /*params*/ ctx[2]);
			set_custom_element_data(vime_embed, "origin", /*origin*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, vime_embed, anchor);

			if (default_slot) {
				default_slot.m(vime_embed, null);
			}

			/*vime_embed_binding*/ ctx[12](vime_embed);
			current = true;

			if (!mounted) {
				dispose = [
					listen(vime_embed, "vEmbedSrcChange", /*onEvent*/ ctx[5]),
					listen(vime_embed, "vEmbedMessage", /*onEvent*/ ctx[5]),
					listen(vime_embed, "vEmbedLoaded", /*onEvent*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			}

			if (!current || dirty & /*embedSrc*/ 1) {
				set_custom_element_data(vime_embed, "embed-src", /*embedSrc*/ ctx[0]);
			}

			if (!current || dirty & /*mediaTitle*/ 2) {
				set_custom_element_data(vime_embed, "media-title", /*mediaTitle*/ ctx[1]);
			}

			if (!current || dirty & /*params*/ 4) {
				set_custom_element_data(vime_embed, "params", /*params*/ ctx[2]);
			}

			if (!current || dirty & /*origin*/ 8) {
				set_custom_element_data(vime_embed, "origin", /*origin*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(vime_embed);
			if (default_slot) default_slot.d(detaching);
			/*vime_embed_binding*/ ctx[12](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let __ref;
	let __mounted = false;
	const dispatch = createEventDispatcher();
	let { embedSrc = undefined } = $$props;
	let { mediaTitle = undefined } = $$props;
	let { params = undefined } = $$props;
	let { origin = undefined } = $$props;
	let { preconnections = undefined } = $$props;
	let { decoder = undefined } = $$props;
	const postMessage = (...args) => __ref.postMessage(...args);
	const getWebComponent = () => __ref;

	onMount(() => {
		$$invalidate(13, __mounted = true);
	});

	const setProp = (prop, value) => {
		if (__ref) $$invalidate(4, __ref[prop] = value, __ref);
	};

	const onEvent = e => {
		e.stopPropagation();
		dispatch(e.type, e.detail);
	};

	let { $$slots = {}, $$scope } = $$props;

	function vime_embed_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			__ref = $$value;
			$$invalidate(4, __ref);
		});
	}

	$$self.$$set = $$props => {
		if ("embedSrc" in $$props) $$invalidate(0, embedSrc = $$props.embedSrc);
		if ("mediaTitle" in $$props) $$invalidate(1, mediaTitle = $$props.mediaTitle);
		if ("params" in $$props) $$invalidate(2, params = $$props.params);
		if ("origin" in $$props) $$invalidate(3, origin = $$props.origin);
		if ("preconnections" in $$props) $$invalidate(6, preconnections = $$props.preconnections);
		if ("decoder" in $$props) $$invalidate(7, decoder = $$props.decoder);
		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*__mounted, preconnections*/ 8256) {
			$: if (__mounted) setProp("preconnections", preconnections);
		}

		if ($$self.$$.dirty & /*__mounted, decoder*/ 8320) {
			$: if (__mounted) setProp("decoder", decoder);
		}
	};

	return [
		embedSrc,
		mediaTitle,
		params,
		origin,
		__ref,
		onEvent,
		preconnections,
		decoder,
		postMessage,
		getWebComponent,
		$$scope,
		$$slots,
		vime_embed_binding
	];
}

class VimeEmbed extends SvelteComponent {
  $$prop_def: VimeEmbedProps;
  $$events_def: VimeEmbedEvents;
  $$slot_def: VimeEmbedSlots;

  $on<K extends keyof VimeEmbedEvents>(type: K, callback: (e: VimeEmbedEvents[K]) => any): () => void {
	  return super.$on(type, callback);
	}

  $set($$props: Partial<VimeEmbedProps>): void {
	  super.$set($$props);
	}

	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			embedSrc: 0,
			mediaTitle: 1,
			params: 2,
			origin: 3,
			preconnections: 6,
			decoder: 7,
			postMessage: 8,
			getWebComponent: 9
		});
	}

	
  /** Posts a message to the embedded media player. */
 get postMessage(): Components.VimeEmbed["postMessage"] {
		return this.$$.ctx[8];
	}

	get getWebComponent(): HTMLVimeEmbedElement | undefined {
		return this.$$.ctx[9];
	}
}

export default VimeEmbed;